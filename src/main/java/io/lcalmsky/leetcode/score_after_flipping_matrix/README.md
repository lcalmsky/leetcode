# 풀이

이 문제를 해결하기 위해선 bit-shift를 활용해야 합니다.

먼저 전체 소스 코드 입니다.

```java
public class Solution {
    public int matrixScore(int[][] A) {
        int rows = A.length, cols = A[0].length, result = (1 << (cols - 1)) * rows;
        for (int i = 1; i < cols; ++i) {
            int cnt = 0;
            for (int[] row : A) if (row[i] == row[0]) cnt++;
            result += Math.max(cnt, rows - cnt) * (1 << (cols - 1 - i));
        }
        return result;
    }
}
```

차근차근 살펴보면

```java
int rows = A.length, cols = A[0].length, result = (1 << (cols - 1)) * rows;
```

이 부분에선 먼저 행과 열의 갯수를 구하고, 첫 번 째 열을 모두 1로 만들었다고 가정하여 결과를 계산합니다.  
예시로 주어진 행렬을 예로 들면

```
0 0 1 1
1 0 1 0
1 1 0 0
```

행은 3개, 열은 4개로 맨 앞자리를 1로 만들었다고 가정하면 얻을 수 있는 최솟값은 다음과 같습니다.

```
1 ? ? ?
1 ? ? ?
1 ? ? ?
```

2진수 1???는 8 + ?가 될 것이므로 최솟값은 8 입니다.  
열이 3개 이므로 8 * 3인 24가 이 행렬을 flipping & toggle 했을 때 최솟값이 됩니다.  
이 값을 구하기 위한 수식은 아래와 같습니다.

```
1 << (cols - 1)
```

한 행의 첫 번 째 원소가 1이 되었을 때의 2진수 값을 구하기 위해선 열의 갯수 - 1 만큼 bit-shift 시켜주면 됩니다.

```
1 << 3 = 1000
```

다시 한 번 정리하자면, 가장 처음에 처리해야할 작업은 첫 번 째 열을 모두 1로 만든다는 가정하에 최솟값을 구하는 것 입니다.  
2진수의 특성상 맨 앞자리 수를 제외한 나머지 자리 수를 모두 더해도 맨 앞자리 수보다 최소 1이 모자라게 되기 때문에 이 문제에서 요구하는 최고 점수 획들을 위해선 앞자리를 1로 만들어 주는 것이 중요합니다.

```java
for (int i = 1; i < cols; ++i) {
    int cnt = 0;
    for (int[] row : A) if (row[i] == row[0]) cnt++;
    result += Math.max(cnt, rows - cnt) * (1 << (cols - 1 - i));
}
```

다음으로 맨 앞 자리를 모두 1로 만들어줬다고 가정했기 때문에 그 다음 반복문에서는 두 번 째 열(1번 인덱스) 부터 탐색하게 됩니다.  
각 열을 탐색하면서 첫 번 째 열과 값이 같은 경우 `cnt` 값을 올려줍니다.  
`i = 1` 일 때

```
i: 0 1 2 3
   0 0 1 1 << 0, 1 동일
   1 0 1 0
   1 1 0 0 << 0, 1 동일
```

2가지 경우가 열의 값이 같기 때문에 `toggle` 해서 (1, 1)로 만들거나 그대로 둬서 (1, 1)로 만들 수 있습니다.  
반면, 2번 째 행의 경우 (1, 0) 또는 (0, 1)일 것이고 앞 자리를 1로 만들기위해 반드시 toggle 할 것이기 때문에 (1, 0)이 이 행이 가질 수 있는 최댓값 입니다. 위에서 구한 최솟값과 동일하기
때문에 취급할 필요가 없습니다.  
다시 말하면, 앞에서 `cnt를` 증가시킨 케이스는 모두 (1, 1)이 되는 케이스 입니다.  
그럼 두 번 째 열이 1이 될 수 있는 경우가 두 가지가 되는 것이고 이를 계산해 결괏값에 더해줍니다.  
앞에서 사용한 `bit-shift`를 이용해 값을 구할 수 있습니다.

```
cols - 1 - i
```

이 부분은 전체 열에서 1을 빼준 뒤 현재 탐색하고 있는 열의 인덱스를 빼줘서 `shift` 해야 할 `bit` 수를 구합니다. 그 이후 1을 해당 `bit` 만큼 `shift` 해주면 현재 열을 1로 바꿨을 때의
값을 구할 수 있습니다.

```
1 << cols - 1 - i
i = 1:
1 << 4 - 1 - 1
1 << 2 = 100 = 4
```

현재 열을 1로 바꿨을 때의 값은 4이므로 바꾼 행(cnt)만큼 곱해 이전에 구한 결괏값에 더해줍니다.

```
현재 행을 1로 바꿨을 때의 값: 4 * 2 = 8
결괏값: 24 + 8 = 32
```

예시에서는 2번 째 열을 1로 만들 수 있는 경우가 2였기 때문에 1로 만들지 못하는 경우보다 더 컸습니다.  
반대의 경우(첫 번 째 열과 비교했을 때 값이 다른 경우)가 더 큰 경우 그 열 자체를 toggle 하는 것이 이득일 것 입니다.  
예를 들면

```
0 1 ? ?
1 0 ? ?
1 1 ? ?
```

위의 경우 1, 2번 행은 1, 2번 열의 값이 다릅니다. 앞자리를 1로 만든다는 가정하에 다음과 같은 행렬이 될 수 있습니다.

```
// 1번 행 toggle
1 0 ? ?
1 0 ? ?
1 1 ? ?
```

이렇게 되면 두 번 째 열을 toggle 하는 것이 더 큰 점수를 얻을 수 있게 해줍니다.  
따라서

```java
Math.max(cnt, rows - cnt)
```

이 부분에서 cnt는 행을 `toggle`하거나 그대로 뒀을 때 최대가 되는 갯수, `rows - cnt`는 열을 `toggle`하거나 그대로 뒀을 때 최대가 되는 갯수를 구한 것으로, 둘 중 더 높은 값과
bit-shift를 이용해 구한 현재 열의 값을 곱해서 더해주면 결과가 최댓값이 됩니다.

다음 열 부터는 같은 행위의 반복입니다.  
앞자리에 대해서는 이미 구했기 때문에 신경쓸 필요가 없고 맨 앞자리 값을 1로 만들면서 행을 `toggle`할지, 열을 `toggle`할지에 대해서만 고민하면 됩니다.
